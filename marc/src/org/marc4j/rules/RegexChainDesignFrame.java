package org.marc4j.rules;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.util.Arrays;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.marc4j.MarcStreamReader;
import org.marc4j.marc.Record;

/**
 * RegexChainDesignFrame.java created by levenick on Jun 1, 2014 at 11:46:12 AM
 */
public class RegexChainDesignFrame extends javax.swing.JFrame {

    private int recordCount;
    String inputFileName;

    public RegexChainDesignFrame(String inputFileName) {
        initComponents();
        this.inputFileName = inputFileName;
        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        setSize(600, 500);
        setTitle("Experiment with regex chain");
        setVisible(true);
    }

    /**
     * You can't modify the following code; it is regenerated by the Form
     * Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jScrollPane1 = new javax.swing.JScrollPane();
        theTA = new javax.swing.JTextArea();
        goDisplayButton = new javax.swing.JButton();
        fieldsTF = new javax.swing.JTextField();
        jScrollPane2 = new javax.swing.JScrollPane();
        outTA = new javax.swing.JTextArea();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        theTA.setColumns(20);
        theTA.setRows(5);
        theTA.setText("(color|col).*(with|and some)\n(color|col).*and.*(b\\.w|b&w|b & w|bw|b+w|black.*&.*white)\n(b\\.w|b&w|b & w|bw|b+w|black.*&.*white).*(with|and)\n(b\\.w|b&w|b & w|bw|b+w|black.*&.*white).*(some)\nchiefly b&w\npart (color|col)\n(color|col).*;\n(color|col).*;.*(b\\.w|b&w|b & w|bw|b+w|black.*&.*white)\nsepia\ntinted\n(b\\.w|b&w|b & w|bw|b+w|black.*&.*white).*(color|col)\n(b\\.w|b&w|b & w|bw|b+w|black.*&.*white)");
        jScrollPane1.setViewportView(theTA);

        getContentPane().add(jScrollPane1, java.awt.BorderLayout.CENTER);

        goDisplayButton.setText("Push to test regex");
        goDisplayButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                goDisplayButtonActionPerformed(evt);
            }
        });
        getContentPane().add(goDisplayButton, java.awt.BorderLayout.PAGE_START);

        fieldsTF.setText("300b");
        fieldsTF.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                fieldsTFActionPerformed(evt);
            }
        });
        getContentPane().add(fieldsTF, java.awt.BorderLayout.PAGE_END);

        outTA.setColumns(20);
        outTA.setRows(5);
        jScrollPane2.setViewportView(outTA);

        getContentPane().add(jScrollPane2, java.awt.BorderLayout.LINE_END);

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void fieldsTFActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_fieldsTFActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_fieldsTFActionPerformed

    private void goDisplayButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_goDisplayButtonActionPerformed
        tryAllRegex();
        goDisplayButton.setText("" + getRecordCount());
    }//GEN-LAST:event_goDisplayButtonActionPerformed

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JTextField fieldsTF;
    private javax.swing.JButton goDisplayButton;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JTextArea outTA;
    private javax.swing.JTextArea theTA;
    // End of variables declaration//GEN-END:variables

    StringCounterList busted;

    private void tryAllRegex() {
        String where = fieldsTF.getText();
        MarcStreamReader theMarcReader = resetInputFile();
        StringList list = inputRegex();
        StringCounterList ctrList = new StringCounterList();

        for (String nextS : list) {
            ctrList.add(nextS);
        }  // so there's no 0's!
        /*
         for each record 
         for each regex
         if matches(field$char)
         countmatches (or add to StringCounterList)
         break
         */
        FieldSpecifier theField = new FieldSpecifier(where);
        busted = new StringCounterList();

        while (theMarcReader.hasNext()) {
            recordCount++;
            Record aRecord = theMarcReader.next();
            boolean foundOne = false;
            String nextDataGah = Utils.getFirstDataFromFieldAndSubfield(aRecord, theField);

            for (String nextS : list) {
                if (regexMatches(aRecord, nextS, theField)) {
                    ctrList.add(nextS);
                    foundOne = true;
                    break;
                }
            }
            if (!foundOne) {
                busted.add(nextDataGah);
            }

        }

        displayResults(ctrList);

    }

    private boolean regexMatches(Record theRecord, String regex, FieldSpecifier theFieldSpec) {
        //System.out.println("gonna match " + regex + " to " + theFieldSpec);
        int fieldNumber = theFieldSpec.getFieldNumber();
        char subFieldChar = theFieldSpec.getSubfieldChar();
        StringList list = Utils.getDataFromFieldAndSubfield(theRecord, fieldNumber, subFieldChar);

        for (String nextData : list) {
            Pattern pattern = Pattern.compile(regex);
            Matcher matcher = pattern.matcher(nextData);

            if (matcher.find()) {
                //System.out.println("matched!");
                return true;
            }
        }

        return false; //none matched
    }

    private int getRecordCount() {
        return recordCount;
    }

    private MarcStreamReader resetInputFile() {
        MarcStreamReader returnMe = null;
        setRecordCount(0);
        try {
            returnMe = new MarcStreamReader(new BufferedInputStream(new FileInputStream(inputFileName)));

        } catch (Exception e) {
            Globals.panic("failed to open " + inputFileName);
        }

        return returnMe;
    }

    private void setRecordCount(int n) {
        recordCount = n;
    }

    private StringList inputRegex() {
        StringList returnMe = new StringList();

        String everything = theTA.getText();
        String[] regexes = everything.split("\n");
        returnMe.addAll(Arrays.asList(regexes));

        return returnMe;
    }

    private void displayResults(StringCounterList ctrList) {
        outTA.setText("");
        for (StringCounter nextSC : ctrList) {
            nextSC.decrement();  // so the counts are right...
        }
        for (StringCounter nextSC : ctrList) {
            outTA.append("" + nextSC.getCount() + "\n");
            //System.out.println("nextSC = " + nextSC);
        }
        outTA.append("total: " + ctrList.getTotal());
        new DisplayRegexMatchesFrame("these didn't match", busted);
    }

}
